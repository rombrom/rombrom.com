#!/usr/bin/env sh

set -e

RE_ESCAPE='[]\/$*.^[]'
RE_PARTIAL='\(>[[:blank:]]*(.+[[:blank:]]*)\)'

esc_re() {
  echo $(sed -E "s/$RE_ESCAPE/\\\&/g" < /dev/stdin)
}

parse() {
  local output="$(</dev/stdin)"
  local dir="${1:-$PWD}"

  # loop through unique filenames read from the expression:
  # (> path/to/file)
  # 1. grep for our pattern and only list the result (-o)
  # 2. remove the expression syntax and keep the file path
  # 3. make sure we have no duplicates
  for partial_file in $(grep -oE "$RE_PARTIAL" <<< "$output" \
    | sed -E "s/$RE_PARTIAL/\1/" \
    | uniq); do

    # create a RegEx for this specific file
    local esc_partial_file=$(esc_re <<< "$partial_file")
    local re="\(>[[:blank:]]*$esc_partial_file[[:blank:]]*\)"

    # let sed operate on the $output where we
    # 1. replace expression with content
    # 2. recursively parse includes in $partial_file
    output=$(sed -E \
      -e "/$re/ {
          r $dir/$partial_file
          d
        }" \
      <<< "$output" \
      | parse "$(dirname "$partial_file")")

  done;

  # and return the output
  echo "$output"
}

main() {
  local files="$1"
  for template_file in "$files"; do
    parse < "$template_file"
  done
}

if [[ -z "$1" ]]; then
  echo "Missing argument 1: filepath or glob." 1>&2
  exit 2
fi

main "$1"
