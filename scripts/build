#!/usr/bin/env bash

set -e

args=""
cmd=""

opt_delimiters="()"
opt_output_dir="dist"

RE_INCLUDE="\\${opt_delimiters:0:1}>[[:blank:]]*(.+[[:blank:]]*)\\${opt_delimiters:1:1}"

# TODO: this might be obsolete now?
log() {
  if [[ "$opt_verbose" = true ]]; then
    printf "%s\n" "$@"
  fi
}

# log error and exit
# @param string
# @return string
# @exit
err() {
  printf "%s\n" "$@" >&2
  exit 1
}

# escape special characters so the string can safely be used
# in a regex
# @param string
# @return string
esc_re() {
  printf '%s' "$1" | sed "s/[]})\/.?^|$+*({[]/\\\&/g"
}

esc_ref() {
  printf '%s' "$1" | sed "s/[&]/\\\&/g"
}

# parses a string for shmatic expressions and returns an evaluated string
# @param string
# @param directory
# @return string
parse() {
  local output="$1"
  local context="$2"

  if [[ -d "$context" ]]; then
    cd "$context"
  fi

  output="$(parse_includes "$output")"

  printf '%s\n' "$output"
}

# parses a string for include expressions and evaluates them.
# recursively calls parse() to check whether we need to continue
# evaluation for other expressions
# @param string
# @return string
parse_includes() {
  local output="$1"

  # create a list of includeRecords, consisting of
  # [file]:[expression]
  # 1. grep for our pattern and only list the result (-o)
  # 2. remove the expression syntax and keep the file path
  # 3. make sure we have no duplicates
  local includes="$(printf %s "$output" \
    | grep -oE "$RE_INCLUDE" \
    | sed -E "s/$RE_INCLUDE/\1:&/" \
    | uniq)"

  # if there are no includes, bail
  if [[ -z "$includes" ]]; then
    printf '%s' "$output"
    return
  fi

  # includes is a list of includeRecords, consisting of:
  # [path]:[expression]
  # NOTE: I'm not sure why, but using for...in does not work here
  # the altnerative is using a while loop which reads every line
  # of input from a variable passed to while with <<<
  # alas this is not really portable to sh
  while read -r includeRecord; do
    local path="${includeRecord%:*}"
    local exp_re="$(esc_re "${includeRecord#*:}")"
    local content="$(esc_ref "$(cat $path 2>&1)")"

    # use awk gsub to replace any include expressions
    # with the content of the partial.
    # NOTE: This was a wild ride. sed, being heavily line based made it
    # difficult to work with ranges. awk on MacOS (apparently) didn't want
    # to play nice with variables passed with awk -v.
    # Thank you, fprimex
    # https://github.com/hashicorp-community/tf-helper/issues/1#issuecomment-490656096
    # replace the include expression with the partial's content
    output="$(awk "BEGIN {
        content=ARGV[1]; delete ARGV[1];
        output=ARGV[2]; delete ARGV[2];
        gsub(/$exp_re/, content, output);
        print output
      }" "$content" "$output" \
    )"

    # recursively parse includes in $partial_file
    output="$(parse "$output" $(dirname "$path"))"

  # TODO: the <<< syntax does not work in sh. It does in bash,
  # zsh and probably others. This feels like coding for IE6 again.
  done <<< "$includes"

  printf '%s\n' "$output"
}

# parse files
# @param any?
# TODO: this should write the files to the output directory,
# taking into account the creation of subdirectories where
# necessary
parse_files() {
  local cwd="$PWD";

  for path in $@; do
    local realpath="$path"

    # check for an absolute path
    if [[ ! "${realpath:0:1}" = '/' ]]; then
      realpath="$cwd/$realpath"
    fi

    if [[ ! -f "$realpath" ]]; then
      err "File not found: $realpath"
    fi

    parse "$(<$realpath)" "$(dirname $realpath)"
  done
}

# loop through arguments and options
while [[ "$#" -ne 0 ]]; do
  case "$1" in
    --debug)
      PS4='$LINENO: '
      set -x
      ;;
    *)
      args+="$1 "
      ;;
  esac
  shift
done

# kick everything off
parse_files "$args"
